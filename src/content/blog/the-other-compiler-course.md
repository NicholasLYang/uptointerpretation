---
title: "The Other Programming Language Course"
pubDate: "Apr 5, 2025"
draft: true
---

Welcome to the Other Programming Language Course, where you learn the
other 99% of writing a programming language. What will we be covering?

## Syntax Highlighting

You've been writing your language as plaintext because you're a
compiler nerd who can hallucinate syntax highlighting. Nobody else
wants that. Let's figure out how to get decent syntax highlighting in
editors that people actually use, i.e. not emacs.

## Documentation

RTFM? First we need to Write TFM. Let's figure out how to document
your language. Hint, random professor's webpages with no CSS and
lecture slides are *not* it. While we're at it, let's figure out how
to document the compiler's code. We want people contributing, right?
Right?

## Evangelizing

They say there's only two kinds of languages, those that are
complained about and those that nobody use. Let's get some people
complaining! We'll go over how to give a short talk about your
language without using the word "pure"; how to write a blog post that
people might read; and finally, how to stop assuming that people who
don't like your language are just too stupid to get it.

## Error Messages

What the hell is a type unification error? Let's figure out how to
make error messages that regular programmers can actually
read. Including decent code snippets, suggested fixes, and links to
those docs you totally wrote.

## Syntax Errors

Your cool LALR parser generator uses the latest, hottest parsing
theory from 1985, but CAN. IT. RECOVER? Turns out it sucks when your
parser stops at the first error. And what about giving your user a
good error message with some suggestions on what they were trying to
write? Is that too much to ask?

## Linters

Your language has all the hot new superlinear affine homotopy type
theory that ensures you will never write incorrect code. But what
about plain crappy code? For that, we need a linter.

## Formatters

How many people write a language without a formatter these days? Let's
go over the standard pretty printing paper and write one for your
language. Warning, this might be harder than the actual compiler!

## IDEs and Language Servers

Yes, yes, I know you wrote your compiler using ctags in vim. But the
rest of the world has realized that IDEs are actually pretty nice!
Let's go over how compilers have become language analysis services and
how that requires fundamentally rethinking their
architecture. Pipelines are so 2000's.

# Not Covering

We will not be covering:

- Regular expressions
- Finite automata
- Formal grammars
- Parser generators
- LLVM
- The Dragon Book

For that, go to literally any other course.

